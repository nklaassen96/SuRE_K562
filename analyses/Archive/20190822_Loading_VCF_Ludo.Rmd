---
title: "20192208 Journal Week 1"
author: "Noud Klaassen"
date: "22-8-2019"
output: html_document
---

**Ludo:**
Be less descriptive about what you do (" .... I downloaded the ...). But also more detailed, here in where and how you got the datafiles, including origin, method of retrieval, and date. Eg;

## Input data
Data is a VCF file downloaded from https://......, using `wget https://.....`, on 2019-08-20

**end Ludo**

**Edit Noud**
Data is a VCF file downloaded from https://www.encodeproject.org/files/ENCFF606RIC/@@download/ENCFF606RIC.vcf.gz which was retrieved by using `wget https://www.encodeproject.org/files/ENCFF606RIC/@@download/ENCFF606RIC.vcf.gz' on 2019-08-20

**end Edit**
I Downloaded the VCF-files from the K562-paper (non-phased) and read them into an R table. Comment.char makes sure that the rows that start with an # will be removed 

```{r setup, eval = TRUE ,include=TRUE}
K562_IndelSNV_NF <- read.table("~/projects/SuRE_K562/data/external/Encode_K562_VCF/ENCFF606RIC.vcf.gz", comment.char = "#",)
colnames(K562_IndelSNV_NF) <- c("CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", 'INFO', 'FORMAT', 'K562_PE')
```

**Ludo:**
If possible retrieve the column names from the data file itself to minimize potential mistakes. In this case the R-function `read.table` doesn't allow to specify a comment character consisting of more than 1 character. So you  can't simply say `read.table(filename, comment.char="##", ...)` to only skip the header. Here you could have read the first 1000 lines or so (including the header; `lines <- readLines(filename, n=1000)`), find the line with column names (`headerline <- grep("^# ", lines, value=TRUE)`, extract column names (`colnames <- strsplit(x=headerline, split=" ")`, etc). But this is a lot of work. data import function from for instance the packages readr or data.table may handle this case much better (I'm not sure).

**end Ludo**


Next, I generated a histogram displaying the distribution plot of the QUAL scores of the different variants that were called (including SNVs and Indels)

```{r, eval=TRUE}
hist(K562_IndelSNV_NF[,6], col = 3, xlab = "QUAL", xlim = c(0, 6000),breaks = 1000, main = "Variant Calling Quality")
```

**Ludo:**
If you set the xlim explicitly make sure you don't miss unexpected data. Eg, show a summary of the data first (`summary(K562_IndelSNV_NF[,"QUAL"])`). Also (important) use column names instead of index numbers. This makes it clear what you are doing whereas numbers can be very confusing.
**End Ludo**

Then, I wanted to count the number of variants (SNVs and Indels), by using a loop. In this loop, I use the paste-function to generate the required character to search for right chromosome. The nrow-function wil count the number of rows that have been generated for a certain chromosome. Thes counts are stored in the Count-variable.

**Ludo:**
```
CHRnames <- c(paste0("chr", 1:22), "chrX")
for (chr in CHRnames) {
  Chr_i_list <- K562_IndelSNV_NF[which(K562_IndelSNV_NF$CHROM == chr),]
  .
  .
  
```

or simply `Count <- table(K562_IndelSNV_NF$CHROM)`;
** End Ludo**



```{r,eval=TRUE}
Count = c()
for (i in 1:23) {
  if (i == 23) {i <- c("X")}
        Chr_i = paste("chr", i, sep="")
        print(Chr_i)
        Chr_i_list <- K562_IndelSNV_NF[which(K562_IndelSNV_NF$CHROM == Chr_i),]
        MNV_Count <- nrow(Chr_i_list)
        print(MNV_Count)
  if (i == "X") {i <- 23}
        Count[i] <- MNV_Count
}
```

These values can then be plotted in a bar-graph
```{r, eval=TRUE}
barplot(Count,space = 0.2,names.arg = c(1:23), col = 2, xlab = "Chromosome", ylab = "# of Multi-nucleotide Variants (MNV)")
```
In the next step I wanted to separate the SNVs from the Indels. To do that i needed to transform the ALT and REF columns from factors to characters, so the length of the characters could be determined by nchar-function. In this way, only the variations that have 1 nt in their REF-sequence and 1-nt in the ALT sequence will be kept.

```{r, eval=TRUE}
Nt_REF <- nchar(as.character(K562_IndelSNV_NF[,4])) #Count nr. of characters of REF in a vector
SNV_REF_Only <- K562_IndelSNV_NF[which(Nt_REF == 1),] #Filter in the database for REF==1
Nt_ALT <- nchar(as.character(SNV_REF_Only[,5])) #Count in the new database nr of characters in ALT
SNV_list <- SNV_REF_Only[which(Nt_ALT == 1),]
```

** Ludo:**
While reading the data you can specify that character columns should NOT be converted to factors (arguments "as.is=TRUE" or "stringsAsFactors=FALSE").
Now you could say something like `which(nchar(K562_IndelSNV_NF[,"REF"])==1 & nchar(K562_IndelSNV_NF[,"ALT"])==1))`

You've called a couple of variables ..._List but these are in fact array's (SNV_list) or data frames (Chr_i_list). Be careful about not to imply a certain data type if it is not.
**End Ludo**

## Rsession
```{r session}
sessionInfo()
```
============
