# This script is designed to process generated by the SuRE-Pipeline
# and rewrite to R objects per chromosome per replicate

# First load the required libraries
library(data.table)
library(tidyverse)
#install.packages("splitstackshape")
library(splitstackshape)


#### Loading the SNPtxt files into R ####
# This can be done with the txt.gz files directly and do not need 
# to be unzipped


dir.input <- "/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Indels_gDNA_Count/"

for (replicate in c("SuRE42-1/", "SuRE42-2/", "SuRE43-1/", "SuRE43-2/", "SuRE44-1/", "SuRE44-2/")){


for (chrom in c(1:2)){
  

  sure.indel.allparent <- NULL

  for (parent in c("equal", "maternal", "paternal")){
  
    system.time({
    
    file.name <- paste0(dir.input, replicate, parent, "/", chrom, ".bedpe.gz")
    
    print(paste0("starting with analysis of ", file.name, " at ", Sys.time()))
  
    # Read the count-file as a data.table   
  
    sure.BCcounts <- fread(file.name, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
    
    print("read")

  
    # Remove empty rows (that do not contain a variant)
  
    sure.BCcounts <- sure.BCcounts[sure.BCcounts$SNP_ID != ""]
    
    # Remove some rows that contain SNPs (compared to indels) this makes
    # the separate_rows() function a lot faster
    
# sure.BCcounts <- sure.BCcounts[sure.BCcounts$SNP_TYPE != "snp" & sure.BCcounts$SNP_TYPE != "snp,snp" & sure.BCcounts$SNP_TYPE != "snp,snp,snp"]

  
    # for each SNP_ID, separate the id's based on the comma
  
    snp.sep.list <- strsplit(sure.BCcounts$SNP_ID, split = ",")
  

    # for each element in the list, check if there are similar values. I also 
    # want to know where they are. because it could be [id1, id1, id2]. I dont 
    # think it can be [id1, id2, id1]
    # The function below creates a list for which TRUE indicates whether this is the second appearance or not (1st value is FALSE)
  
    snp.duplicates <- lapply(snp.sep.list, duplicated)

  
    # First I separate all the rows based on the comma of the SNP_SEQ row
    # because this is the only column in which elements can end with ","
    # which the separate_rows() function can deal nicely with. Now the other
    # columns can be replaced simply with the strsplit() function. 
 
    x <- separate_rows(sure.BCcounts, SNP_SEQ, sep = ",")
  
    # As the separates was only performed on the SNP_SEQ column, the other columns
    # need to be splitted as well. This is done with the strsplit() function. Subsequently
    # new columns are added to the dataframe
    
    col.abspos <- unlist(strsplit(sure.BCcounts$SNP_ABS_POS, split = ","))
    col.id <- unlist(strsplit(sure.BCcounts$SNP_ID, split = ","))
    col.par <- unlist(strsplit(sure.BCcounts$SNP_PARENT, split = ","))
    col.var <- unlist(strsplit(sure.BCcounts$SNP_VAR, split = ","))
    col.type <- unlist(strsplit(sure.BCcounts$SNP_TYPE, split = ","))
    col.subtype <- unlist(strsplit(sure.BCcounts$SNP_SUBTYPE, split = ","))
    col.absposhg19 <- unlist(strsplit(sure.BCcounts$SNP_ABS_POS_hg19, split = ","))
    
    x$SNP_ABS_POS <- col.abspos
    x$SNP_ID <- col.id
    x$SNP_PARENT <- col.par
    x$SNP_VAR <- col.var
    x$SNP_TYPE <- col.type
    x$SNP_SUBTYPE <- col.subtype
    x$SNP_ABS_POS_hg19 <- col.absposhg19

    # Now we have a data frame `x` with only the variants in them, which are the same length as the
    # list `snp.duplicates`. This list contains FALSE for each row that we want to keep, and TRUE
    # for each row that we want to remove.
  
    x <- x[!unlist(snp.duplicates)]
    
    # Previous dataframe still contains SNPs and Indels. As we are only interested in indels, we can
    # filter them with the "SNP_Type" column
    
    sure.indel <- x[x$SNP_TYPE == "indel"]
    
    # Combine the `equal`, `maternal` and `paternal` data into 1 object
    
    sure.indel.allparent <- rbind(sure.indel.allparent, sure.indel)
    })
  }
  
  saveRDS(sure.indel.allparent, file = paste0(dir.input, replicate, "combined/","sure.counts.indel.", chrom, ".RDS"))
  
}
}   

# TESTSET


system.time(
# OPTION 1
x <- separate_rows(sure.BCcounts.tst, SNP_ID, SNP_ABS_POS:SNP_SUBTYPE, SNP_ABS_POS_hg19, sep = ",")
# END OPTION 1
)

system.time({
# OPTION 2
sure.BCcounts.tst <- sure.BCcounts[1:100000]
#sure.BCcounts.tst <- sure.BCcounts.tst[sure.BCcounts.tst$SNP_TYPE != "snp" & sure.BCcounts.tst$SNP_TYPE != "snp,snp" & sure.BCcounts.tst$SNP_TYPE != "snp,snp,snp"]  

x <- separate_rows(sure.BCcounts.tst, SNP_SEQ, sep = ",")
col.abspos <- unlist(strsplit(sure.BCcounts.tst$SNP_ABS_POS, split = ","))
col.id <- unlist(strsplit(sure.BCcounts.tst$SNP_ID, split = ","))
col.par <- unlist(strsplit(sure.BCcounts.tst$SNP_PARENT, split = ","))
col.var <- unlist(strsplit(sure.BCcounts.tst$SNP_VAR, split = ","))
col.type <- unlist(strsplit(sure.BCcounts.tst$SNP_TYPE, split = ","))
col.subtype <- unlist(strsplit(sure.BCcounts.tst$SNP_SUBTYPE, split = ","))
col.absposhg19 <- unlist(strsplit(sure.BCcounts.tst$SNP_ABS_POS_hg19, split = ","))

x$SNP_ABS_POS <- col.abspos
x$SNP_ID <- col.id
x$SNP_PARENT <- col.par
x$SNP_VAR <- col.var
x$SNP_TYPE <- col.type
x$SNP_SUBTYPE <- col.subtype
x$SNP_ABS_POS_hg19 <- col.absposhg19
# END OPTION 2
})


list.abspos <- strsplit(sure.BCcounts.tst$SNP_ABS_POS, split = ",")
list.seq <- strsplit(sure.BCcounts.tst$SNP_SEQ, split = ",")

strings.q <- sapply(list.abspos, length)
strings.s <- sapply(list.seq, length)

#strings.q <- str_count(sure.BCcounts.tst$SNP_ABS_POS, pattern = ",")
#strings.s <- str_count(sure.BCcounts.tst$SNP_SEQ, pattern = ",")
which(strings.q != strings.s)

'
sure.BCcounts.tst <- sure.BCcounts[1:100000,]
system.time(
tst <- separate_rows(sure.BCcounts.tst, SNP_ID, sep = ",")
)
system.time(
tst2 <- cSplit(sure.BCcounts.tst, splitCols = c(cn[2]), sep = ",", direction = 'long', makeEqual = FALSE)
)
#make my own 'separate rows' algorithm 

col.1.split <- strsplit(sure.BCcounts.tst[,1])
col.8.split <- strsplit(sure.BCcounts.tst[,8])
col.9.split <- strsplit(sure.BCcounts.tst[,9])
col.10.split <- strsplit(sure.BCcounts.tst[,10])
col.11.split <- strsplit(sure.BCcounts.tst[,11])
col.12.split <- strsplit(sure.BCcounts.tst[,12])
col.13.split <- strsplit(sure.BCcounts.tst[,13])
col.21.split <- strsplit(sure.BCcounts.tst[,21])





snp.per.row <- sapply(col.1.split, length)



