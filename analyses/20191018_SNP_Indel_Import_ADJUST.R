# This script is designed to process indels generated by the SuRE-Pipeline
# and rewrite to R objects per chromosome per replicate
# Run script in tmux commandline with /usr/bin/time -v nice -19 R --no-save -q < /tmp/tt.R > /tmp/tt.Rout

# First load the required libraries
library(data.table)
library(tidyverse)
library(foreach)
library(doMC)
registerDoMC(cores = 30)


rep1.files.vector <- paste0("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP170216_SuRE42/SuRE-pipelineOutput/", list.files("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP170216_SuRE42/SuRE-pipelineOutput/",pattern = "inf"))[c(1:22,24)]
rep3.files.vector <- paste0("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP170216_SuRE43/SuRE43-pipelineOutput/",list.files("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP170216_SuRE43/SuRE43-pipelineOutput/", pattern = "inf"))[c(1:22,24)]
rep5.files.vector <- paste0("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP170216_SuRE44/SuRE44-pipelineOutput/",list.files("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP170216_SuRE44/SuRE44-pipelineOutput/", pattern = "inf"))[c(1:22,24)]
rep7.files.vector <- paste0("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP170216_SuRE45_1/SuRE45_1-pipelineOutput/",list.files("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP170216_SuRE45_1/SuRE45_1-pipelineOutput/", pattern = "inf"))[c(1:22,24)]
rep8.files.vector <- paste0("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP170216_SuRE45_2/SuRE45_2-pipelineOutput/",list.files("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP170216_SuRE45_2/SuRE45_2-pipelineOutput/", pattern = "inf"))[c(1:22,24)]
rep2.files.vector <- paste0("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP180619_SuRE42_2/pipelineOutput/", list.files("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP180619_SuRE42_2/pipelineOutput/", pattern = "txt.gz"))
rep4.files.vector <- paste0("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP180619_SuRE43_2/pipelineOutput/", list.files("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP180619_SuRE43_2/pipelineOutput/", pattern = "txt.gz"))
rep6.files.vector <- paste0("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP180619_SuRE44_2/pipelineOutput/", list.files("/DATA/usr/ludo/projects/LP140430_SureSeq_JvArensbergen/analyses/LP180619_SuRE44_2/pipelineOutput/", pattern = "txt.gz"))

file.list <- list(rep1.files.vector,
                  rep2.files.vector,
                  rep3.files.vector,
                  rep4.files.vector,
                  rep5.files.vector,
                  rep6.files.vector,
                  rep7.files.vector,
                  rep8.files.vector)

rep.vector <- c("42_1","42_2","43_1","43_2","44_1","44_2","45_1","45_2")

registerDoMC(cores = 8)

foreach(rep.idx = c(1:8)) %dopar% {  
  
  # retrieve all files in a vector for this replicate
  file.vector <- unlist(file.list[rep.idx])
  
  # Genarate a string that can be used to name and identify files
  rep.str <- rep.vector[rep.idx]
  
  
  
  # First step is to normalize the data per replicate, to do that,
  # we need the total amount of ipcr counts and cdna counts. The
  # foreach loops provide a simple way to count the sum of the aforementioned
  # variables
  
  #check whether the normalizing file is already there, otherwise, generate it
  
  read.totals.file <- paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/read.totals.rep.",rep.idx,".RDS")
  
  if (file.exists(read.totals.file)) {
    sum.counts <-readRDS(read.totals.file)[,1]
    sum.cdna1 <- readRDS(read.totals.file)[,2]
    sum.cdna2 <- readRDS(read.totals.file)[,3]
    sum.cdna3 <- readRDS(read.totals.file)[,4]
    sum.cdna4 <- readRDS(read.totals.file)[,5]
    sum.cdna5 <- readRDS(read.totals.file)[,6]
    } else {
    sum.counts <-sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = c("iPCR")))}))
    sum.cdna1 <- sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = 11))}))
    sum.cdna2 <- sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = 12))}))
    sum.cdna3 <- sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = 13))}))
    sum.cdna4 <- sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = 14))}))
    sum.cdna5 <- sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = 15))}))
    
    saveRDS(object = data.frame(sum.counts, sum.cdna1, sum.cdna2, sum.cdna3, sum.cdna4, sum.cdna5, row.names ="total counts"), file = read.totals.file)
    }
  
  

  # START LOOPING THROUGH THE FILES PER CHROMOSOME
  
  for (chr.idx in c(1:22, "X")){
    
    file.idx <- grep(pattern = paste0("chr", chr.idx,"."), file.vector, fixed = TRUE)
    file.name <- file.vector[file.idx]
    
    print(paste0(Sys.time(), " starting rep ", rep.str," chr", chr.idx, " -- ", file.name))
    
    
    # Read the count-file as a data.table and remove empty rows (that do not contain a variant)
    # and some rows that contain 1, 2 or 3 snps to speed up the separate_rows() function
    
    sure.BCcounts <- fread(file.name, header = TRUE, sep = "\t", stringsAsFactors = FALSE, drop = c("start", "end","strand", "SNPrelpos", "PAT_MAT","SNPidx"))
    
    # rename iPCR to count to ease programming
    
    colnames(sure.BCcounts)[5] = "count"
    
    sure.BCcounts <- sure.BCcounts[sure.BCcounts$SNP_ID != ""]
    
      
    # START DOWNSAMPLING
    
    
    # retrieve files from the NatGen paper
    downsample.k562.42.1 <- readRDS(file = "/DATA/usr/n.klaassen/projects/SuRE_K562/data/external/Downsampling.vectors.joris/k562.downsampling.vector.SuRE42_1.180803 (2).rds")
    downsample.hepg2.42.1 <-readRDS(file = "/DATA/usr/n.klaassen/projects/SuRE_K562/data/external/Downsampling.vectors.joris/HepG2.downsampling.vector.SuRE42_1.180803.rds")
    downsample.hepg2.43.1 <-readRDS(file = "/DATA/usr/n.klaassen/projects/SuRE_K562/data/external/Downsampling.vectors.joris/HepG2.downsampling.vector.SuRE43_1.180803.rds")
    
    #downsample 42_1 (K562 & HepG2)
    if (rep.str == "42_1"){
      
      
      
      
      sure.BCcounts <- as.data.frame(sure.BCcounts)
      sure.BCcounts$number <- seq(1:nrow(sure.BCcounts))
      
      for (i in 1:5){
        
        
        # check column names
        #print(i)
        print(colnames(sure.BCcounts)[5+i])
        
        # make dataframe otherwise it will be harder to script
        sure.BCcounts <- as.data.frame(sure.BCcounts)
        
        # downsample from the cDNA values
        snpcounts <- rep(sure.BCcounts$number, sure.BCcounts[,5+i])
        
        snpcounts.sample <- sample(snpcounts, size = round(
          length(snpcounts) * c(downsample.k562.42.1,downsample.hepg2.42.1)[i],
          digits = 0))
        
        sure.BCcounts[,5+i] = 0
        
        sure.BCcounts[match(names(table(snpcounts.sample)),sure.BCcounts$number), 5+i] <- table(snpcounts.sample)
      }
      
      # return back to data.table and remove the previously added "number" column   
      sure.BCcounts$number <- NULL
      sure.BCcounts <- as.data.table(sure.BCcounts)
      
    }
    
    #downsample 43_1 (HepG2 only)
    if (rep.str == "43_1"){
      
      
      
      sure.BCcounts <- as.data.frame(sure.BCcounts)
      sure.BCcounts$number <- seq(1:nrow(sure.BCcounts))
      
      for (i in 1:2){
        
        
        # check column names
        print(i)
        print(colnames(sure.BCcounts)[8+i])
        
        # make dataframe otherwise it will be harder to script
        sure.BCcounts <- as.data.frame(sure.BCcounts)
        
        # downsample
        snpcounts <- rep(sure.BCcounts$number, sure.BCcounts[,8+i])
        
        snpcounts.sample <- sample(snpcounts, size = round(
          length(snpcounts) * c(downsample.hepg2.43.1)[i],
          digits = 0))
        
        sure.BCcounts[,8+i] = 0
        
        sure.BCcounts[match(names(table(snpcounts.sample)),sure.BCcounts$number),8+i] <- table(snpcounts.sample)
      }
      
      # return back to data.table and remove the previously added "number" column   
      sure.BCcounts$number <- NULL
      sure.BCcounts <- as.data.table(sure.BCcounts)  
      
    }
    
    
    
    print("read counts")
    
    ## For some gDNA fragments, the variant within this fragment is sequenced twice,
    ## once in the forward and once in the reverse read. In this case a single row will 
    ## contain the same snp id twice. All second reads of this variant are removed with the 
    ## following code.
    
    # for each SNP_ID, separate the id's based on the comma
    
    snp.sep.list <- strsplit(sure.BCcounts$SNP_ID, split = ",")
    
    
    # for each element in the list, check if there are similar values. The function below 
    # creates a list for which TRUE indicates whether this is the second appearance or not (1st value is FALSE)
    
    snp.duplicates <- lapply(snp.sep.list, duplicated)
    
    
    # First I separate all the rows based on the comma of the SNP_SEQ row
    # because this is the only column in which elements can end with ","
    # which the separate_rows() function can deal nicely with. Now the other
    # columns can be replaced simply with the strsplit() function. 
    
    x <- separate_rows(sure.BCcounts, SNPbase, SNPbaseInf, SNPabspos, sep = ",")
    print("separated")
    
    # As the separates was only performed on the SNP_SEQ column, the other columns
    # need to be splitted as well. This is done with the strsplit() function. Subsequently
    # new columns are added to the dataframe
    
    x$SNP_ID <-           unlist(strsplit(sure.BCcounts$SNP_ID, split = ","))
    x$SNPvar <-          unlist(strsplit(sure.BCcounts$SNPvar, split = ","))
    x$SNPvarInf <-          unlist(strsplit(sure.BCcounts$SNPvarInf, split = ","))
    
    # Now we have a data frame `x` with only the variants in them, which are the same length as the
    # list `snp.duplicates`. This list contains FALSE for each row that we want to keep, and TRUE
    # for each row that we want to remove.
    
    sure.snp <- x[!unlist(snp.duplicates)]
    
    # make a numeric column of the SNP_ABS_POS_hg19
    
    sure.snp$SNPabspos <- as.numeric(sure.snp$SNPabspos)

  
  # Add a column for the library
  sure.snp$library <- rep.str
  
  
  # After the end of the loop through the chromosomes there is an R 
  # Object (`sure.indel.allchrom`) that contains all desired variants
  # for one specific replicate. iPCR data (`counts`) and cDNA counts 
  # (e.g. SuRE42_2_HepG2_B1) should be normalized to reads per billion
  #
  # With this we have to keep in mind that we downsampled for 42.1 (both cell lines) and 43.1 (HepG2 only), therefore
  # we also have to adjust the normalization for these samples
  
  if (rep.str == "42_1"){
    sure.snp$count <- round(sure.snp$count / sum.counts * 1e9, digits = 2)
    sure.snp[,6]   <- round(sure.snp[,6] / (sum.cdna1 * c(downsample.k562.42.1,downsample.hepg2.42.1)[1]) * 1e9, digits = 1)
    sure.snp[,7]  <- round(sure.snp[,7] / (sum.cdna2 * c(downsample.k562.42.1,downsample.hepg2.42.1)[2]) * 1e9, digits = 1)
    sure.snp[,8]  <- round(sure.snp[,8] / (sum.cdna3 * c(downsample.k562.42.1,downsample.hepg2.42.1)[3]) * 1e9, digits = 1)
    sure.snp[,9]  <- round(sure.snp[,9] / (sum.cdna4 * c(downsample.k562.42.1,downsample.hepg2.42.1)[4]) * 1e9, digits = 1)
    sure.snp[,10]  <- round(sure.snp[,10] / (sum.cdna5 * c(downsample.k562.42.1,downsample.hepg2.42.1)[5]) * 1e9, digits = 1)
  } else if (rep.str == "43_1") {
    sure.snp$count <- round(sure.snp$count / sum.counts * 1e9, digits = 2)
    sure.snp[,6]   <- round(sure.snp[,6] / sum.cdna1 * 1e9, digits = 1)
    sure.snp[,7]  <- round(sure.snp[,7] / sum.cdna2 * 1e9, digits = 1)
    sure.snp[,8]  <- round(sure.snp[,8] / sum.cdna3 * 1e9, digits = 1)
    sure.snp[,9]  <- round(sure.snp[,9] / (sum.cdna4 * downsample.hepg2.43.1[1]) * 1e9, digits = 1)
    sure.snp[,10]  <- round(sure.snp[,10] / (sum.cdna5 * downsample.hepg2.43.1[2]) * 1e9, digits = 1)
  } else {
    sure.snp$count <- round(sure.snp$count / sum.counts * 1e9, digits = 2)
    sure.snp[,6]   <- round(sure.snp[,6] / sum.cdna1 * 1e9, digits = 1)
    sure.snp[,7]  <- round(sure.snp[,7] / sum.cdna2 * 1e9, digits = 1)
    sure.snp[,8]  <- round(sure.snp[,8] / sum.cdna3 * 1e9, digits = 1)
    sure.snp[,9]  <- round(sure.snp[,9] / sum.cdna4 * 1e9, digits = 1)
    sure.snp[,10]  <- round(sure.snp[,10] / sum.cdna5 * 1e9, digits = 1)
  }
  
  # To concatonate the R objects containing all chromosomes for every replicate,
  # The columnnames of these objects should be an exact match. For every first replicate (e.g. 44-1) and 45-2
  # They are in the order K562 B1-B3 and then HepG2 B1-2. While for every second replicate (e.g. 44-2)
  # The order is reversed (HepG2 B1-B2 followed by K562 B1-B3). Column names are altered with the following script
  
  print(head(sure.snp))
  if (rep.str %in% (c("42_1","43_1","44_1", "45_1", "45_2"))){
    colnames(sure.snp)[6:10] <- c("cDNA.K562.B1", "cDNA.K562.B2", "cDNA.K562.B3", "cDNA.HepG2.B1", "cDNA.HepG2.B2")} else {
    colnames(sure.snp)[6:10] <- c("cDNA.HepG2.B1", "cDNA.HepG2.B2", "cDNA.K562.B1", "cDNA.K562.B2", "cDNA.K562.B3")
    }
  print(head(sure.snp))
  
  # Average the data of the 3 (K562) or 2 (HepG2) biological replicates and normalize to ipcr counts
  
  sure.snp$cDNA.K562.sum.norm <- (sure.snp$cDNA.K562.B1 + sure.snp$cDNA.K562.B2 + sure.snp$cDNA.K562.B3) / 3
  sure.snp$cDNA.HepG2.sum.norm <- (sure.snp$cDNA.HepG2.B1 + sure.snp$cDNA.HepG2.B2) / 2
  
  sure.snp$cDNA.K562.norm.ipcr <- sure.snp$cDNA.K562.sum.norm / sure.snp$count
  sure.snp$cDNA.HepG2.norm.ipcr <- sure.snp$cDNA.HepG2.sum.norm / sure.snp$count
  
  # For every chromosome, the R object containing the variants is saved
  # into the /combined directory of that specific replicate
  
  saveRDS(sure.snp, file = paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/sure.reads.", rep.str,".chr", chr.idx, ".RDS"))
  
  
} ### END LOOP CHROM 1:22,X ###
  
  print(paste(rep.str, "finished at", Sys.time()))
  gc()
  
} ### END LOOP REP 1:7 ###


print(paste0("script 1 (importing) completely finished at ", Sys.time()))

gc()



##### SCRIPT 2: COMBINING FILES PER CHROMOSOME #####

# This second part of the script is used to generate separate count files per chromosome for all replicates. 

library(data.table)
library(tidyverse)
library(foreach)
library(doMC)
print(paste0(Sys.time(), " start script 2"))
registerDoMC(cores = 3)

print(paste(Sys.time(), "starting loop"))

foreach(i = c(1:22,"X")) %dopar%{
  
  print(paste("starting analysis of chromosome", i, "at", Sys.time()))
  
  # 1. combinding to one new R object
  
  allrep <- rbind(readRDS(file = paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/sure.reads.42_1.chr", i, ".RDS")),
                  readRDS(file = paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/sure.reads.42_2.chr", i, ".RDS")),
                  readRDS(file = paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/sure.reads.43_1.chr", i, ".RDS")),
                  readRDS(file = paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/sure.reads.43_2.chr", i, ".RDS")),
                  readRDS(file = paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/sure.reads.44_1.chr", i, ".RDS")),
                  readRDS(file = paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/sure.reads.44_2.chr", i, ".RDS")),
                  readRDS(file = paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/sure.reads.45_1.chr", i, ".RDS")),
                  readRDS(file = paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/sure.reads.45_2.chr", i, ".RDS"))
  )
  
  # allrep <- rbind(rep1, rep2, rep3, rep4, rep5, rep6)
  
  
  # check whether all replicates are in there
  print(c(i,table(allrep$library)))
  
  # 2. Save this R object
  
  file.output.name <- paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Test_Old_Data/sure.reads.allrep.chr.", i, ".RDS")
  saveRDS(object = allrep, file = file.output.name)
  gc()
}


print(paste(Sys.time(), "end script 2"))








