# This script is designed to process indels generated by the SuRE-Pipeline
# and rewrite to R objects per chromosome per replicate
# Run script in tmux commandline with /usr/bin/time -v nice -19 R --no-save -q < /tmp/tt.R > /tmp/tt.Rout

# First load the required libraries
library(data.table)
library(tidyverse)
library(foreach)
library(doMC)
registerDoMC(cores = 10)


dir.input <- "/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Indels_gDNA_Count/"

#sure.snp_indel.allrep <- NULL
replicate <- "SuRE42-1/" # Sure45 first because this one is the most likely to give errorsss.

rowsum.counts <- NULL
rowsum.cdna1 <- NULL
rowsum.cdna2 <- NULL
rowsum.cdna3 <- NULL
rowsum.cdna4 <- NULL
rowsum.cdna5 <- NULL

rowsumaftersplit.counts <- NULL
rowsumaftersplit.cdna1 <- NULL
rowsumaftersplit.cdna2 <- NULL
rowsumaftersplit.cdna3 <- NULL
rowsumaftersplit.cdna4 <- NULL
rowsumaftersplit.cdna5 <- NULL

### ### ### ### ### ### ### 44-1 AND ARE NOT BEING DONE, BE WARY FOR THIS!!! ONLY 7 REPS ### ### ### ### ### ###

#for (replicate in c("SuRE42-1/", "SuRE42-2/", "SuRE43-1/", "SuRE43-2/", "SuRE44-2/","SuRE45-1/", "SuRE45-2/")){
#foreach(replicate = c("SuRE42-1/", "SuRE42-2/", "SuRE43-1/", "SuRE43-2/", "SuRE44-2/","SuRE45-1/", "SuRE45-2/")) %dopar% {  
foreach(replicate = c("SuRE44-1/")) %dopar% {    
  # First step is to normalize the data per replicate, to do that,
  # we need the total amount of ipcr counts and cdna counts. The
  # foreach loops provide a simple way to count the sum of the aforementioned
  # variables
  
  
  f1 <- paste0(dir.input,replicate)
  f2 <- rep(c("paternal/", "maternal/", "equal/"), times = 23) 
  f3 <- rep(c(1:22, "X"), each = 3) 
  f4 <- ".bedpe.gz"
  file.vector <- paste0(f1,f2,f3,f4) 
  
  #check whether the file is already there, otherwise, generate it
  
  read.totals.file <- paste0(dir.input, replicate, "read.totals.RDS")
  
  if (file.exists(read.totals.file)) {
    sum.counts <-readRDS(read.totals.file)[,1]
    sum.cdna1 <- readRDS(read.totals.file)[,2]
    sum.cdna2 <- readRDS(read.totals.file)[,3]
    sum.cdna3 <- readRDS(read.totals.file)[,4]
    sum.cdna4 <- readRDS(read.totals.file)[,5]
    sum.cdna5 <- readRDS(read.totals.file)[,6]
    } else {
    sum.counts <-sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = c("count")))}))
    sum.cdna1 <- sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = 14))}))
    sum.cdna2 <- sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = 15))}))
    sum.cdna3 <- sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = 16))}))
    sum.cdna4 <- sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = 17))}))
    sum.cdna5 <- sum(unlist(foreach(k = c(1:length(file.vector))) %dopar% {sum(fread(file.vector[k], header = TRUE, sep = "\t", stringsAsFactors = FALSE, select = 18))}))
    
    saveRDS(object = data.frame(sum.counts, sum.cdna1, sum.cdna2, sum.cdna3, sum.cdna4, sum.cdna5, row.names ="total counts"), file = paste0(dir.input, replicate, "read.totals.RDS"))
    }
  
  
  # Genarate a string that can be used to name and identify files
  rep.str <- str_replace(string = str_remove_all(replicate, pattern = "[SuRE/]"), pattern = "-", replacement = "_")
  
  #sure.snp_indel.allchrom <- NULL
  
  for (chrom in c(1:22, "X")){
    
    
    print(paste0("starting with analysis of replicate ", replicate, " chrom ", chrom , " at ", Sys.time()))
    
    sure.snp_indel.allparent <- NULL
    
    for (parent in c("equal", "maternal", "paternal")){
      
      print(paste("start", parent, "at", Sys.time()))
      file.name <- paste0(dir.input, replicate, parent, "/", chrom, ".bedpe.gz")
      
      
      # Read the count-file as a data.table and remove empty rows (that do not contain a variant)
      # and some rows that contain 1, 2 or 3 snps to speed up the separate_rows() function
      
      sure.BCcounts <- fread(file.name, header = TRUE, sep = "\t", stringsAsFactors = FALSE, drop = c("BC", "start", "end", "SNP_ABS_POS", "SNP_SUBTYPE", "start_hg19", "end_hg19"))
      sure.BCcounts <- sure.BCcounts[sure.BCcounts$SNP_ID != ""]
      
      
      # testing testing testing testing downsampling
            
      
            # retrieve files from the NatGen paper
            downsample.k562.42.1 <- readRDS(file = "/DATA/usr/n.klaassen/projects/SuRE_K562/data/external/Downsampling.vectors.joris/k562.downsampling.vector.SuRE42_1.180803 (2).rds")
            downsample.hepg2.42.1 <-readRDS(file = "/DATA/usr/n.klaassen/projects/SuRE_K562/data/external/Downsampling.vectors.joris/HepG2.downsampling.vector.SuRE42_1.180803.rds")
            downsample.hepg2.43.1 <-readRDS(file = "/DATA/usr/n.klaassen/projects/SuRE_K562/data/external/Downsampling.vectors.joris/HepG2.downsampling.vector.SuRE43_1.180803.rds")
            
            #downsample 42_1 (K562 & HepG2)
            if (rep.str == "42_1"){
            
              
              
              
              sure.BCcounts <- as.data.frame(sure.BCcounts)
              sure.BCcounts$number <- seq(1:nrow(sure.BCcounts))
            
              for (i in 1:5){
           
              
                # check column names
                #print(i)
                print(colnames(sure.BCcounts)[8+i])
                
                # make dataframe otherwise it will be harder to script
                sure.BCcounts <- as.data.frame(sure.BCcounts)
                
                # downsample from the cDNA values
                snpcounts <- rep(sure.BCcounts$number, sure.BCcounts[,8+i])
                
                snpcounts.sample <- sample(snpcounts, size = round(
                  length(snpcounts) * c(downsample.k562.42.1,downsample.hepg2.42.1)[i],
                  digits = 0))
                
                sure.BCcounts[,8+i] = 0
                
                sure.BCcounts[match(names(table(snpcounts.sample)),sure.BCcounts$number), i + 8] <- table(snpcounts.sample)
              }
            
            # return back to data.table and remove the previously added "number" column   
            sure.BCcounts$number <- NULL
            sure.BCcounts <- as.data.table(sure.BCcounts)
              
            }
            
            #downsample 43_1 (HepG2 only)
            if (rep.str == "43_1"){
              
              
              
              sure.BCcounts <- as.data.frame(sure.BCcounts)
              sure.BCcounts$number <- seq(1:nrow(sure.BCcounts))
              
              for (i in 1:2){
                
                
                # check column names
                print(i)
                print(colnames(sure.BCcounts)[11+i])
                
                # make dataframe otherwise it will be harder to script
                sure.BCcounts <- as.data.frame(sure.BCcounts)
                
                # downsample
                snpcounts <- rep(sure.BCcounts$number, sure.BCcounts[,11+i])
                
                snpcounts.sample <- sample(snpcounts, size = round(
                  length(snpcounts) * c(downsample.hepg2.43.1)[i],
                  digits = 0))
                
                sure.BCcounts[,11+i] = 0
                
                sure.BCcounts[match(names(table(snpcounts.sample)),sure.BCcounts$number),11+i] <- table(snpcounts.sample)
              }
            
            # return back to data.table and remove the previously added "number" column   
            sure.BCcounts$number <- NULL
            sure.BCcounts <- as.data.table(sure.BCcounts)  
              
            }
        
         
      
      # testing testing testing testing end!
      
      # count to see whether downsampling was correct
      rowsum.counts <- sum(sum(sure.BCcounts$count), rowsum.counts)
      rowsum.cdna1 <- sum(sum(sure.BCcounts[,9]), rowsum.cdna1)
      rowsum.cdna2 <- sum(sum(sure.BCcounts[,10]), rowsum.cdna2)
      rowsum.cdna3 <- sum(sum(sure.BCcounts[,11]), rowsum.cdna3)
      rowsum.cdna4 <- sum(sum(sure.BCcounts[,12]), rowsum.cdna4)
      rowsum.cdna5 <- sum(sum(sure.BCcounts[,13]), rowsum.cdna5)
      
      print("read counts")
      
      ## For some gDNA fragments, the variant within this fragment is sequenced twice,
      ## once in the forward and once in the reverse read. In this case a single row will 
      ## contain the same snp id twice. All second reads of this variant are removed with the 
      ## following code.
      
      # for each SNP_ID, separate the id's based on the comma
      
      snp.sep.list <- strsplit(sure.BCcounts$SNP_ID, split = ",")
      
      
      # for each element in the list, check if there are similar values. The function below 
      # creates a list for which TRUE indicates whether this is the second appearance or not (1st value is FALSE)
      
      snp.duplicates <- lapply(snp.sep.list, duplicated)
      
      
      # First I separate all the rows based on the comma of the SNP_SEQ row
      # because this is the only column in which elements can end with ","
      # which the separate_rows() function can deal nicely with. Now the other
      # columns can be replaced simply with the strsplit() function. 
      
      x <- separate_rows(sure.BCcounts, SNP_SEQ, SNP_ABS_POS_hg19, sep = ",")
      print("separated")
      
      # As the separates was only performed on the SNP_SEQ column, the other columns
      # need to be splitted as well. This is done with the strsplit() function. Subsequently
      # new columns are added to the dataframe
      
      x$SNP_ID <-           unlist(strsplit(sure.BCcounts$SNP_ID, split = ","))
      x$SNP_PARENT <-       unlist(strsplit(sure.BCcounts$SNP_PARENT, split = ","))
      x$SNP_VAR <-          unlist(strsplit(sure.BCcounts$SNP_VAR, split = ","))
      x$SNP_TYPE <-         unlist(strsplit(sure.BCcounts$SNP_TYPE, split = ","))
      
      # Now we have a data frame `x` with only the variants in them, which are the same length as the
      # list `snp.duplicates`. This list contains FALSE for each row that we want to keep, and TRUE
      # for each row that we want to remove.
      
      sure.snp_indel <- x[!unlist(snp.duplicates)]
      
      # make a numeric column of the SNP_ABS_POS_hg19
      
      sure.snp_indel$SNP_ABS_POS_hg19 <- as.numeric(sure.snp_indel$SNP_ABS_POS_hg19)
      
      
      # Combine the `equal`, `maternal` and `paternal` data into 1 object
      
      sure.snp_indel.allparent <- rbind(sure.snp_indel.allparent, sure.snp_indel)
      print("finished rbind to one chromosome file")
      
      
    } ### END LOOP EQUAL/PATERNAL/MATERNAL ###
    
    # remove rows that have NA's in them (mostly in the columns
    # start_hg19 and end_hg19 or in which the variant was not correctly read or 
    # identified (i.e. SNP_Parent is not boundary_ovl, unexpected, or unread)
    
    sure.snp_indel.allparent <- na.omit(sure.snp_indel.allparent)
    sure.snp_indel.allparent <- sure.snp_indel.allparent[sure.snp_indel.allparent$SNP_PARENT != "boundary_ovl" & 
                                                   sure.snp_indel.allparent$SNP_PARENT != "unexpected" & 
                                                   sure.snp_indel.allparent$SNP_PARENT != "unread" &
                                                   sure.snp_indel.allparent$SNP_PARENT != "maternal_unexpected" &
                                                   sure.snp_indel.allparent$SNP_PARENT != "paternal_unexpected" &
                                                   sure.snp_indel.allparent$SNP_PARENT != "non_paternal_allele",]
    
    # Add a column for the library
    sure.snp_indel.allparent$library <- rep.str
    
    
    # After the end of the loop through the chromosomes there is an R 
    # Object (`sure.indel.allchrom`) that contains all desired variants
    # for one specific replicate. iPCR data (`counts`) and cDNA counts 
    # (e.g. SuRE42_2_HepG2_B1) should be normalized to reads per billion
    #
    # With this we have to keep in mind that we downsampled for 42.1 (both cell lines) and 43.1 (HepG2 only), therefore
    # we also have to adjust the normalization for these samples
    
    if (rep.str == "42_1"){
      sure.snp_indel.allparent$count <- round(sure.snp_indel.allparent$count / sum.counts * 1e9, digits = 2)
      sure.snp_indel.allparent[,9]   <- round(sure.snp_indel.allparent[,9] / (sum.cdna1 * c(downsample.k562.42.1,downsample.hepg2.42.1)[1]) * 1e9, digits = 1)
      sure.snp_indel.allparent[,10]  <- round(sure.snp_indel.allparent[,10] / (sum.cdna2 * c(downsample.k562.42.1,downsample.hepg2.42.1)[2]) * 1e9, digits = 1)
      sure.snp_indel.allparent[,11]  <- round(sure.snp_indel.allparent[,11] / (sum.cdna3 * c(downsample.k562.42.1,downsample.hepg2.42.1)[3]) * 1e9, digits = 1)
      sure.snp_indel.allparent[,12]  <- round(sure.snp_indel.allparent[,12] / (sum.cdna4 * c(downsample.k562.42.1,downsample.hepg2.42.1)[4]) * 1e9, digits = 1)
      sure.snp_indel.allparent[,13]  <- round(sure.snp_indel.allparent[,13] / (sum.cdna5 * c(downsample.k562.42.1,downsample.hepg2.42.1)[5]) * 1e9, digits = 1)
    } else if (rep.str == "43_1") {
      sure.snp_indel.allparent$count <- round(sure.snp_indel.allparent$count / sum.counts * 1e9, digits = 2)
      sure.snp_indel.allparent[,9]   <- round(sure.snp_indel.allparent[,9] / sum.cdna1 * 1e9, digits = 1)
      sure.snp_indel.allparent[,10]  <- round(sure.snp_indel.allparent[,10] / sum.cdna2 * 1e9, digits = 1)
      sure.snp_indel.allparent[,11]  <- round(sure.snp_indel.allparent[,11] / sum.cdna3 * 1e9, digits = 1)
      sure.snp_indel.allparent[,12]  <- round(sure.snp_indel.allparent[,12] / (sum.cdna4 * downsample.hepg2.43.1[1]) * 1e9, digits = 1)
      sure.snp_indel.allparent[,13]  <- round(sure.snp_indel.allparent[,13] / (sum.cdna5 * downsample.hepg2.43.1[2]) * 1e9, digits = 1)
    } else {
      sure.snp_indel.allparent$count <- round(sure.snp_indel.allparent$count / sum.counts * 1e9, digits = 2)
      sure.snp_indel.allparent[,9]   <- round(sure.snp_indel.allparent[,9] / sum.cdna1 * 1e9, digits = 1)
      sure.snp_indel.allparent[,10]  <- round(sure.snp_indel.allparent[,10] / sum.cdna2 * 1e9, digits = 1)
      sure.snp_indel.allparent[,11]  <- round(sure.snp_indel.allparent[,11] / sum.cdna3 * 1e9, digits = 1)
      sure.snp_indel.allparent[,12]  <- round(sure.snp_indel.allparent[,12] / sum.cdna4 * 1e9, digits = 1)
      sure.snp_indel.allparent[,13]  <- round(sure.snp_indel.allparent[,13] / sum.cdna5 * 1e9, digits = 1)
    }
      
    # check the rowsums for later to see if downsampling was done correctly  
    rowsumaftersplit.counts <- sum(sum(sure.snp_indel.allparent$count), rowsumaftersplit.counts)
    rowsumaftersplit.cdna1 <- sum(sum(sure.snp_indel.allparent[,9]), rowsumaftersplit.cdna1)
    rowsumaftersplit.cdna2 <- sum(sum(sure.snp_indel.allparent[,10]), rowsumaftersplit.cdna2)
    rowsumaftersplit.cdna3 <- sum(sum(sure.snp_indel.allparent[,11]), rowsumaftersplit.cdna3)
    rowsumaftersplit.cdna4 <- sum(sum(sure.snp_indel.allparent[,12]), rowsumaftersplit.cdna4)
    rowsumaftersplit.cdna5 <- sum(sum(sure.snp_indel.allparent[,13]), rowsumaftersplit.cdna5)
    
    

  

  
  
    # To concatonate the R objects containing all chromosomes for every replicate,
    # The columnnames of these objects should be an exact match. For every first replicate (e.g. 44-1) and 45-2
    # They are in the order K562 B1-B3 and then HepG2 B1-2. While for every second replicate (e.g. 44-2)
    # The order is reversed (HepG2 B1-B2 followed by K562 B1-B3). Column names are altered with the following script
  
    print(head(sure.snp_indel.allparent))
    if (replicate %in% (c("SuRE42-1/","SuRE43-1/","SuRE44-1/", "SuRE45-1/", "SuRE45-2/"))){
        colnames(sure.snp_indel.allparent)[9:13] <- c("cDNA.K562.B1", "cDNA.K562.B2", "cDNA.K562.B3", "cDNA.HepG2.B1", "cDNA.HepG2.B2")} else {
        colnames(sure.snp_indel.allparent)[9:13] <- c("cDNA.HepG2.B1", "cDNA.HepG2.B2", "cDNA.K562.B1", "cDNA.K562.B2", "cDNA.K562.B3")
    }
    print(head(sure.snp_indel.allparent))
  
    # Average the data of the 3 (K562) or 2 (HepG2) biological replicates and normalize to ipcr counts
  
    sure.snp_indel.allparent$cDNA.K562.sum.norm <- (sure.snp_indel.allparent$cDNA.K562.B1 + sure.snp_indel.allparent$cDNA.K562.B2 + sure.snp_indel.allparent$cDNA.K562.B3) / 3
    sure.snp_indel.allparent$cDNA.HepG2.sum.norm <- (sure.snp_indel.allparent$cDNA.HepG2.B1 + sure.snp_indel.allparent$cDNA.HepG2.B2) / 2
  
    sure.snp_indel.allparent$cDNA.K562.norm.ipcr <- sure.snp_indel.allparent$cDNA.K562.sum.norm / sure.snp_indel.allparent$count
    sure.snp_indel.allparent$cDNA.HepG2.norm.ipcr <- sure.snp_indel.allparent$cDNA.HepG2.sum.norm / sure.snp_indel.allparent$count
  
    # For every chromosome, the R object containing the variants is saved
    # into the /combined directory of that specific replicate
    
    saveRDS(sure.snp_indel.allparent, file = paste0(dir.input, replicate, "combined/","sure.",  rep.str , ".counts.snp_indel.", chrom, ".RDS"))
    
    
    } ### END LOOP CHROM 1:22,X ###
  
  # check whether downsampling was correct:
  saveRDS(object = data.frame(rowsum.counts, rowsum.cdna1, rowsum.cdna2, rowsum.cdna3, rowsum.cdna4, rowsum.cdna5, row.names ="total counts"), file = paste0(dir.input, replicate, "downsampled.read.totals.RDS"))
  saveRDS(object = data.frame(rowsumaftersplit.counts, rowsumaftersplit.cdna1, rowsumaftersplit.cdna2, rowsumaftersplit.cdna3, rowsumaftersplit.cdna4, rowsumaftersplit.cdna5, row.names ="total counts after split"), file = paste0(dir.input, replicate, "downsampled.after.split.read.totals.RDS"))
  
  # # For every replicate, the R object containing the variants for all chromosomes
  # # is saved into the /combined directory of the respective replicate
  # 
  # saveRDS(sure.snp_indel.allchrom, file = paste0(dir.input, replicate, "combined/", "sure.", rep.str, ".counts.snp_indel.all.RDS"))
  # 
  # # Concatonate the files per replicate into one big file
  # 
  # sure.snp_indel.allrep <- rbind(sure.snp_indel.allrep, sure.snp_indel.allchrom)
  
  print(paste(replicate, "finished at", Sys.time()))
  gc()
} ### END LOOP REP 1:7 ###

# fname <- paste0(dir.input, "sure.snp_indel.6rep.RDS")
# saveRDS(sure.snp_indel.allrep, file = fname)
print(paste0("script 1 (importing) completely finished at ", Sys.time()))

gc()



##### SCRIPT 2: COMBINING FILES PER CHROMOSOME #####

# This second part of the script is used to generate separate count files per chromosome for all replicates. 

library(data.table)
library(tidyverse)
library(foreach)
library(doMC)
print(paste0(Sys.time(), " start script 2"))
registerDoMC(cores = 4)

# define input and output directories

file.input.name <- "/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Indels_gDNA_Count/SuRE"
dir.output <- "/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Indels_gDNA_Count/SuRE_combined/"

# # load the giant datafile
# 
# sure.indel.combined <- readRDS(file = file.input.name)
# 
# print("large dataframe has been read")
# # Retrieve the chromosome numbers as one long vector
# 
# chrom.idx <- (str_remove_all(string = sure.indel.combined$chrom, pattern = "[_paternalmaternal]"))

print(paste(Sys.time(), "starting loop"))

foreach(i = c(1:22,"X")) %dopar%{
  
  print(paste("starting analysis of chromosome", i, "at", Sys.time()))
  
  
  
  # 1. load files for every replicate
  
  # rep1 <- readRDS(file = paste0(file.input.name, "42-1/combined/sure.42_1.counts.snp_indel.", i, ".RDS"))
  # rep2 <- readRDS(file = paste0(file.input.name, "42-2/combined/sure.42_2.counts.snp_indel.", i, ".RDS"))
  # rep3 <- readRDS(file = paste0(file.input.name, "43-1/combined/sure.43_1.counts.snp_indel.", i, ".RDS"))
  # rep4 <- readRDS(file = paste0(file.input.name, "43-2/combined/sure.43_2.counts.snp_indel.", i, ".RDS"))
  # rep5 <- readRDS(file = paste0(file.input.name, "44-1/combined/sure.44_1.counts.snp_indel.", i, ".RDS"))
  # rep6 <- readRDS(file = paste0(file.input.name, "44-2/combined/sure.44_2.counts.snp_indel.", i, ".RDS"))
  # 
  # print(paste(Sys.time(),"files loaded for chromosome", i))
  # 
  # 
  
  # 2. combinding to one new R object
  
  allrep <- rbind(readRDS(file = paste0(file.input.name, "42-1/combined/sure.42_1.counts.snp_indel.", i, ".RDS")),
                  readRDS(file = paste0(file.input.name, "42-2/combined/sure.42_2.counts.snp_indel.", i, ".RDS")),
                  readRDS(file = paste0(file.input.name, "43-1/combined/sure.43_1.counts.snp_indel.", i, ".RDS")),
                  readRDS(file = paste0(file.input.name, "43-2/combined/sure.43_2.counts.snp_indel.", i, ".RDS")),
                  readRDS(file = paste0(file.input.name, "44-1/combined/sure.44_1.counts.snp_indel.", i, ".RDS")),
                  readRDS(file = paste0(file.input.name, "44-2/combined/sure.44_2.counts.snp_indel.", i, ".RDS")),
                  readRDS(file = paste0(file.input.name, "45-1/combined/sure.45_1.counts.snp_indel.", i, ".RDS")),
                  readRDS(file = paste0(file.input.name, "45-2/combined/sure.45_2.counts.snp_indel.", i, ".RDS"))
  )
  
  # allrep <- rbind(rep1, rep2, rep3, rep4, rep5, rep6)
  
  
  # check whether all replicates are in there
  print(c(i,table(allrep$library)))
  
  # 3. Save this R object
  
  file.output.name <- paste0(dir.output, "sure.snp_indel.combined.chrom.", i, ".RDS")
  saveRDS(object = allrep, file = file.output.name)
  gc()
}


print(paste(Sys.time(), "end script 2"))








