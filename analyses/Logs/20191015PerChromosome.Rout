> ### STILL TO DO:
> ### REMOVE ROWS WHERE SNP.ID = "." --> zit al in pvalue script
> ### Toevoegen dat ook bij 45-2 (of 45-1) de kolomnamen omgewisseld worden naar 3/2 of 2/3
> 
> 
> 
> # This script is designed to process indels generated by the SuRE-Pipeline
> # and rewrite to R objects per chromosome per replicate
> # Run script in tmux commandline with /usr/bin/time -v nice -19 R --no-save -q < /tmp/tt.R > /tmp/tt.Rout
> 
> # First load the required libraries
> library(data.table)
> library(tidyverse)
> 
> 
> 
> 
> 
> 
> dir.input <- "/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Indels_gDNA_Count/"
> 
> 
> for (chrom in c(1:22, "X")){  
+   
+   
+   sure.indel.allrep <- NULL
+   
+  for (replicate in c("SuRE42-1/", "SuRE42-2/", "SuRE43-1/", "SuRE43-2/", "SuRE44-1/", "SuRE44-2/" )){
+     
+    
+     # Genarate a string that can be used to name and identify files
+     rep.str <- str_replace(string = str_remove_all(replicate, pattern = "[SuRE/]"), pattern = "-", replacement = "_")
+     
+     print(paste0("starting with analysis of replicate ", replicate, " chrom ", chrom , " at ", Sys.time()))
+     
+     sure.indel.allparent <- NULL
+     
+     for (parent in c("equal", "maternal", "paternal")){
+ 
+       print(paste("start", chrom, replicate, parent, "at", Sys.time()))
+       file.name <- paste0(dir.input, replicate, parent, "/", chrom, ".bedpe.gz")
+ 
+ 
+       # Read the count-file as a data.table and remove empty rows (that do not contain a variant)
+       # and some rows that contain 1, 2 or 3 snps to speed up the separate_rows() function
+ 
+       sure.BCcounts <- fread(file.name, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
+       sure.BCcounts <- sure.BCcounts[sure.BCcounts$SNP_ID != ""]
+       sure.BCcounts <- sure.BCcounts[sure.BCcounts$SNP_TYPE != "snp" & sure.BCcounts$SNP_TYPE != "snp,snp" & sure.BCcounts$SNP_TYPE != "snp,snp,snp"]
+       print("read counts")
+ 
+       ## For some gDNA fragments, the variant within this fragment is sequenced twice,
+       ## once in the forward and once in the reverse read. In this case a single row will
+       ## contain the same snp id twice. All second reads of this variant are removed with the
+       ## following code.
+ 
+       # for each SNP_ID, separate the id's based on the comma
+ 
+       snp.sep.list <- strsplit(sure.BCcounts$SNP_ID, split = ",")
+ 
+ 
+       # for each element in the list, check if there are similar values. The function below
+       # creates a list for which TRUE indicates whether this is the second appearance or not (1st value is FALSE)
+ 
+       snp.duplicates <- lapply(snp.sep.list, duplicated)
+ 
+ 
+       # First I separate all the rows based on the comma of the SNP_SEQ row
+       # because this is the only column in which elements can end with ","
+       # which the separate_rows() function can deal nicely with. Now the other
+       # columns can be replaced simply with the strsplit() function.
+ 
+       x <- separate_rows(sure.BCcounts, SNP_SEQ, sep = ",")
+       print("separated")
+ 
+       # As the separates was only performed on the SNP_SEQ column, the other columns
+       # need to be splitted as well. This is done with the strsplit() function. Subsequently
+       # new columns are added to the dataframe
+ 
+       x$SNP_ABS_POS <-      unlist(strsplit(sure.BCcounts$SNP_ABS_POS, split = ","))
+       x$SNP_ID <-           unlist(strsplit(sure.BCcounts$SNP_ID, split = ","))
+       x$SNP_PARENT <-       unlist(strsplit(sure.BCcounts$SNP_PARENT, split = ","))
+       x$SNP_VAR <-          unlist(strsplit(sure.BCcounts$SNP_VAR, split = ","))
+       x$SNP_TYPE <-         unlist(strsplit(sure.BCcounts$SNP_TYPE, split = ","))
+       x$SNP_SUBTYPE <-      unlist(strsplit(sure.BCcounts$SNP_SUBTYPE, split = ","))
+       x$SNP_ABS_POS_hg19 <- unlist(strsplit(sure.BCcounts$SNP_ABS_POS_hg19, split = ","))
+ 
+       # Now we have a data frame `x` with only the variants in them, which are the same length as the
+       # list `snp.duplicates`. This list contains FALSE for each row that we want to keep, and TRUE
+       # for each row that we want to remove.
+ 
+       x <- x[!unlist(snp.duplicates)]
+ 
+       # Previous dataframe still contains SNPs and Indels. As we are only interested in indels, we can
+       # filter them with the "SNP_Type" column. Also remove rows with ambiguous SNP_ID
+ 
+       sure.indel <- x[x$SNP_TYPE == "indel"]
+       sure.indel <- sure.indel[sure.indel$SNP_ID != "."]
+ 
+       # Combine the `equal`, `maternal` and `paternal` data into 1 object
+ 
+       sure.indel.allparent <- rbind(sure.indel.allparent, sure.indel)
+       print("finished rbind")
+ 
+ 
+     } ### END LOOP EQUAL/PATERNAL/MATERNAL ###
+     
+     # remove rows that have NA's in them (mostly in the columns
+     # start_hg19 and end_hg19 or in which the variant was not correctly read or 
+     # identified (i.e. SNP_Parent is not boundary_ovl, unexpected, or unread)
+     
+     sure.indel.allparent <- na.omit(sure.indel.allparent)
+     sure.indel.allparent <- sure.indel.allparent[sure.indel.allparent$SNP_PARENT != "boundary_ovl" & 
+                                                  sure.indel.allparent$SNP_PARENT != "unexpected" & 
+                                                  sure.indel.allparent$SNP_PARENT != "unread",]
+     
+     # Add a column for the library
+     sure.indel.allparent$library <- rep.str
+     
+     # For every chromosome, the R object containing the variants is saved
+     # into the /combined directory of that specific replicate
+     
+     saveRDS(sure.indel.allparent, file = paste0(dir.input, replicate, "combined/","sure.",  rep.str , ".counts.indel.", chrom, ".RDS"))
+     
+     # The variants are currently in separate files per chromosome. Files per
+     # chromosome are concatonated into a new R object
+     
+     # To concatonate the R objects containing all replicates for every chromosome,
+     # The columnnames of these objects should be an exact match. For every first replicate (e.g. 44-1)
+     # They are in the order K562 B1-B3 and then HepG2 B1-2. While for every second replicate (e.g. 44-2)
+     # The order is reversed (HepG2 B1-B2 followed by K562 B1-B3). Column names are altered with the following script
+     
+     if (replicate %in% (c("SuRE42-1/", "SuRE43-1/", "SuRE44-1/"))) {
+       colnames(sure.indel.allparent)[14:18] <-
+         c("cDNA.K562.B1",
+           "cDNA.K562.B2",
+           "cDNA.K562.B3",
+           "cDNA.HepG2.B1",
+           "cDNA.HepG2.B2")
+     } else {
+       colnames(sure.indel.allparent)[14:18] <-
+         c("cDNA.HepG2.B1",
+           "cDNA.HepG2.B2",
+           "cDNA.K562.B1",
+           "cDNA.K562.B2",
+           "cDNA.K562.B3")
+     }
+     
+     
+     sure.indel.allrep <- rbind(sure.indel.allrep, sure.indel.allparent)
+     
+     
+     print(paste("replicate", replicate,chrom, "finished at", Sys.time()))
+     
+   } ### END LOOP REP 1:6 ###
+   
+   # After the end of the loop through the replicates there is an R 
+   # Object (`sure.indel.allrep`) that contains all replicates for one
+   # chromosome. iPCR data (`counts`) and cDNA counts 
+   # (e.g. SuRE42_2_HepG2_B1) should be normalized to reads per billion
+   
+   sure.indel.allrep$count <- round(sure.indel.allrep$count / sum(sure.indel.allrep$count) * 1e9, digits = 0)
+   sure.indel.allrep[,14]  <- round(sure.indel.allrep[,14] / sum(sure.indel.allrep[,14]) * 1e9, digits = 0)
+   sure.indel.allrep[,15]  <- round(sure.indel.allrep[,15] / sum(sure.indel.allrep[,15]) * 1e9, digits = 0)
+   sure.indel.allrep[,16]  <- round(sure.indel.allrep[,16] / sum(sure.indel.allrep[,16]) * 1e9, digits = 0)
+   sure.indel.allrep[,17]  <- round(sure.indel.allrep[,17] / sum(sure.indel.allrep[,17]) * 1e9, digits = 0)
+   sure.indel.allrep[,18]  <- round(sure.indel.allrep[,18] / sum(sure.indel.allrep[,18]) * 1e9, digits = 0)
+   
+   
+   # Average the data of the 3 (K562) or 2 (HepG2) biological replicates and normalize to ipcr counts
+   
+   sure.indel.allrep$cDNA.K562.sum.norm <- (sure.indel.allrep$cDNA.K562.B1 + sure.indel.allrep$cDNA.K562.B2 + sure.indel.allrep$cDNA.K562.B3) / 3
+   sure.indel.allrep$cDNA.HepG2.sum.norm <- (sure.indel.allrep$cDNA.HepG2.B1 + sure.indel.allrep$cDNA.HepG2.B2) / 2
+   
+   sure.indel.allrep$cDNA.K562.norm.ipcr <- sure.indel.allrep$cDNA.K562.sum.norm / sure.indel.allrep$count
+   sure.indel.allrep$cDNA.HepG2.norm.ipcr <- sure.indel.allrep$cDNA.HepG2.sum.norm / sure.indel.allrep$count
+   
+   
+   
+   
+   # For every chromosome, the R object containing the variants for all replicates
+   # is saved into the /SuRE_combined directory 
+   
+   saveRDS(sure.indel.allrep, file = paste0(dir.input, "SuRE_combined/", "sure.counts.indel.chrom.", chrom, ".RDS"))
+   
+ 
+   print(paste("chromosome", chrom, "finished at", Sys.time()))
+   
+ } ### END LOOP CHROM 1:22 ###
[1] "starting with analysis of replicate SuRE42-1/ chrom 1 at 2019-10-15 14:16:37"
[1] "start 1 SuRE42-1/ equal at 2019-10-15 14:16:37"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE42-1/ maternal at 2019-10-15 14:21:19"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE42-1/ paternal at 2019-10-15 14:22:16"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "replicate SuRE42-1/ 1 finished at 2019-10-15 14:23:44"
[1] "starting with analysis of replicate SuRE42-2/ chrom 1 at 2019-10-15 14:23:44"
[1] "start 1 SuRE42-2/ equal at 2019-10-15 14:23:44"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE42-2/ maternal at 2019-10-15 14:36:54"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE42-2/ paternal at 2019-10-15 14:39:07"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "replicate SuRE42-2/ 1 finished at 2019-10-15 14:43:11"
[1] "starting with analysis of replicate SuRE43-1/ chrom 1 at 2019-10-15 14:43:12"
[1] "start 1 SuRE43-1/ equal at 2019-10-15 14:43:12"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE43-1/ maternal at 2019-10-15 14:49:22"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE43-1/ paternal at 2019-10-15 14:50:48"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "replicate SuRE43-1/ 1 finished at 2019-10-15 14:53:16"
[1] "starting with analysis of replicate SuRE43-2/ chrom 1 at 2019-10-15 14:53:16"
[1] "start 1 SuRE43-2/ equal at 2019-10-15 14:53:16"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE43-2/ maternal at 2019-10-15 15:02:54"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE43-2/ paternal at 2019-10-15 15:05:17"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "replicate SuRE43-2/ 1 finished at 2019-10-15 15:08:44"
[1] "starting with analysis of replicate SuRE44-1/ chrom 1 at 2019-10-15 15:08:44"
[1] "start 1 SuRE44-1/ equal at 2019-10-15 15:08:44"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE44-1/ maternal at 2019-10-15 15:12:12"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE44-1/ paternal at 2019-10-15 15:13:46"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "replicate SuRE44-1/ 1 finished at 2019-10-15 15:15:43"
[1] "starting with analysis of replicate SuRE44-2/ chrom 1 at 2019-10-15 15:15:43"
[1] "start 1 SuRE44-2/ equal at 2019-10-15 15:15:43"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE44-2/ maternal at 2019-10-15 15:25:21"
[1] "read counts"
[1] "separated"
[1] "finished rbind"
[1] "start 1 SuRE44-2/ paternal at 2019-10-15 15:30:28"
[1] "read counts"
[1] "separated"
#Zelf erbij gezet:
Error in `[<-.data.table`(x, j = name, value = value) :
  Supplied 2591097 items to be assigned to 2591845 items of column 'SNP_ABS_POS_hg19'. The RHS length must either be 1 (single values are ok) or match the LHS length exactly. If you wish to 'recycle' the RHS please use rep() explicitly to make this intent clear to readers of your code.
Calls: $<- -> $<-.data.table -> [<-.data.table
Execution halted

