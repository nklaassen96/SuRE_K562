# This script is designed to process indels generated by the SuRE-Pipeline
# and rewrite to R objects per chromosome per replicate
# Run script in tmux commandline with /usr/bin/time -v nice -19 R --no-save -q < /tmp/tt.R > /tmp/tt.Rout

# First load the required libraries
library(data.table)
library(tidyverse)
library(foreach)
library(doMC)
registerDoMC(cores = 8)


dir.input <- "/DATA/usr/n.klaassen/projects/SuRE_K562/data/interim/SuRE_Indels_gDNA_Count/"

replicate = "SuRE42-1/"
#foreach(replicate = c("SuRE42-1/", "SuRE42-2/", "SuRE43-1/", "SuRE43-2/", "SuRE44-1/", "SuRE44-2/","SuRE45-1/", "SuRE45-2/")) %dopar% {  

  # First step is to normalize the data per replicate, to do that,
  # we need the total amount of ipcr counts and cdna counts. The
  # foreach loops provide a simple way to count the sum of the aforementioned
  # variables
  
  
  f1 <- paste0(dir.input,replicate)
  f2 <- rep(c("paternal/", "maternal/", "equal/"), times = 23) 
  f3 <- rep(c(1:22, "X"), each = 3) 
  f4 <- ".bedpe.gz"
  file.vector <- paste0(f1,f2,f3,f4) 
  
  #check whether the file is already there, otherwise, generate it
  
  read.totals.file <- paste0(dir.input, replicate, "read.totals.RDS")
  
  if (file.exists(read.totals.file)) {
    sum.counts <-readRDS(read.totals.file)[,1]
    sum.cdna1 <- readRDS(read.totals.file)[,2]
    sum.cdna2 <- readRDS(read.totals.file)[,3]
    sum.cdna3 <- readRDS(read.totals.file)[,4]
    sum.cdna4 <- readRDS(read.totals.file)[,5]
    sum.cdna5 <- readRDS(read.totals.file)[,6]
  } 
  
  
  # Genarate a string that can be used to name and identify files
  rep.str <- str_replace(string = str_remove_all(replicate, pattern = "[SuRE/]"), pattern = "-", replacement = "_")
  

    chrom <- "15"
    
    print(paste0("starting with analysis of replicate ", replicate, " chrom ", chrom , " at ", Sys.time()))
    
    sure.snp_indel.allparent <- NULL
    
    for (parent in c("equal", "maternal", "paternal")){
      
      print(paste("start", parent, "at", Sys.time()))
      file.name <- paste0(dir.input, replicate, parent, "/", chrom, ".bedpe.gz")
      
      
      # Read the count-file as a data.table and remove empty rows (that do not contain a variant)
      # and some rows that contain 1, 2 or 3 snps to speed up the separate_rows() function
      
      sure.BCcounts <- fread(file.name, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
      sure.BCcounts <- sure.BCcounts[sure.BCcounts$SNP_ID != ""]
      
      
      
      
      # retrieve files from the NatGen paper
      downsample.k562.42.1 <- readRDS(file = "/DATA/usr/n.klaassen/projects/SuRE_K562/data/external/Downsampling.vectors.joris/k562.downsampling.vector.SuRE42_1.180803 (2).rds")
      downsample.hepg2.42.1 <-readRDS(file = "/DATA/usr/n.klaassen/projects/SuRE_K562/data/external/Downsampling.vectors.joris/HepG2.downsampling.vector.SuRE42_1.180803.rds")
      downsample.hepg2.43.1 <-readRDS(file = "/DATA/usr/n.klaassen/projects/SuRE_K562/data/external/Downsampling.vectors.joris/HepG2.downsampling.vector.SuRE43_1.180803.rds")
      
      #downsample 42_1 (K562 & HepG2)
      if (rep.str == "42_1"){
        
        
        
        
        sure.BCcounts <- as.data.frame(sure.BCcounts)
        sure.BCcounts$number <- seq(1:nrow(sure.BCcounts))
        
        for (i in 1:5){
          
          
          # check column names
          #print(i)
          print(colnames(sure.BCcounts)[13+i])
          
          # make dataframe otherwise it will be harder to script
          sure.BCcounts <- as.data.frame(sure.BCcounts)
          
          # downsample from the cDNA values
          snpcounts <- rep(sure.BCcounts$number, sure.BCcounts[,13+i])
          
          snpcounts.sample <- sample(snpcounts, size = round(
            length(snpcounts) * c(downsample.k562.42.1,downsample.hepg2.42.1)[i],
            digits = 0))
          
          sure.BCcounts[,13+i] = 0
          
          sure.BCcounts[match(names(table(snpcounts.sample)),sure.BCcounts$number), i + 13] <- table(snpcounts.sample)
        }
        
        # return back to data.table and remove the previously added "number" column   
        sure.BCcounts$number <- NULL
        sure.BCcounts <- as.data.table(sure.BCcounts)
        
      }
      
      #downsample 43_1 (HepG2 only)
      if (rep.str == "43_1"){
        
        
        
        sure.BCcounts <- as.data.frame(sure.BCcounts)
        sure.BCcounts$number <- seq(1:nrow(sure.BCcounts))
        
        for (i in 1:2){
          
          
          # check column names
          print(i)
          print(colnames(sure.BCcounts)[16+i])
          
          # make dataframe otherwise it will be harder to script
          sure.BCcounts <- as.data.frame(sure.BCcounts)
          
          # downsample
          snpcounts <- rep(sure.BCcounts$number, sure.BCcounts[,16+i])
          
          snpcounts.sample <- sample(snpcounts, size = round(
            length(snpcounts) * c(downsample.hepg2.43.1)[i],
            digits = 0))
          
          sure.BCcounts[,16+i] = 0
          
          sure.BCcounts[match(names(table(snpcounts.sample)),sure.BCcounts$number),16+i] <- table(snpcounts.sample)
        }
        
        # return back to data.table and remove the previously added "number" column   
        sure.BCcounts$number <- NULL
        sure.BCcounts <- as.data.table(sure.BCcounts)  
        
      }
      
      
      print("read counts")
      
      ## For some gDNA fragments, the variant within this fragment is sequenced twice,
      ## once in the forward and once in the reverse read. In this case a single row will 
      ## contain the same snp id twice. All second reads of this variant are removed with the 
      ## following code.
      
      # for each SNP_ID, separate the id's based on the comma
      
      snp.sep.list <- strsplit(sure.BCcounts$SNP_ID, split = ",")
      
      
      # for each element in the list, check if there are similar values. The function below 
      # creates a list for which TRUE indicates whether this is the second appearance or not (1st value is FALSE)
      
      snp.duplicates <- lapply(snp.sep.list, duplicated)
      
      
      # First I separate all the rows based on the comma of the SNP_SEQ row
      # because this is the only column in which elements can end with ","
      # which the separate_rows() function can deal nicely with. Now the other
      # columns can be replaced simply with the strsplit() function. 
      
      x <- separate_rows(sure.BCcounts, SNP_SEQ, SNP_ABS_POS_hg19, sep = ",")
      print("separated")
      
      # As the separates was only performed on the SNP_SEQ column, the other columns
      # need to be splitted as well. This is done with the strsplit() function. Subsequently
      # new columns are added to the dataframe
      
      x$SNP_ID <-           unlist(strsplit(sure.BCcounts$SNP_ID, split = ","))
      x$SNP_PARENT <-       unlist(strsplit(sure.BCcounts$SNP_PARENT, split = ","))
      x$SNP_VAR <-          unlist(strsplit(sure.BCcounts$SNP_VAR, split = ","))
      x$SNP_TYPE <-         unlist(strsplit(sure.BCcounts$SNP_TYPE, split = ","))
      x$SNP_ABS_POS <-      unlist(strsplit(sure.BCcounts$SNP_ABS_POS, split = ","))
      
      # Now we have a data frame `x` with only the variants in them, which are the same length as the
      # list `snp.duplicates`. This list contains FALSE for each row that we want to keep, and TRUE
      # for each row that we want to remove.
      
      sure.snp_indel <- x[!unlist(snp.duplicates)]
      
      # make a numeric column of the SNP_ABS_POS_hg19
      
      sure.snp_indel$SNP_ABS_POS_hg19 <- as.numeric(sure.snp_indel$SNP_ABS_POS_hg19)
      
      
      # Combine the `equal`, `maternal` and `paternal` data into 1 object
      
      sure.snp_indel.allparent <- rbind(sure.snp_indel.allparent, sure.snp_indel)
      print("finished rbind to one chromosome file")
      
      
    } ### END LOOP EQUAL/PATERNAL/MATERNAL ###
    
    # remove rows that have NA's in them (mostly in the columns
    # start_hg19 and end_hg19 or in which the variant was not correctly read or 
    # identified (i.e. SNP_Parent is not boundary_ovl, unexpected, or unread)
    
    sure.snp_indel.allparent <- na.omit(sure.snp_indel.allparent)
    sure.snp_indel.allparent <- sure.snp_indel.allparent[sure.snp_indel.allparent$SNP_PARENT != "boundary_ovl" & 
                                                           sure.snp_indel.allparent$SNP_PARENT != "unexpected" & 
                                                           sure.snp_indel.allparent$SNP_PARENT != "unread" &
                                                           sure.snp_indel.allparent$SNP_PARENT != "maternal_unexpected" &
                                                           sure.snp_indel.allparent$SNP_PARENT != "paternal_unexpected" &
                                                           sure.snp_indel.allparent$SNP_PARENT != "non_paternal_allele",]
    
    # Add a column for the library
    sure.snp_indel.allparent$library <- rep.str
    
    
    # After the end of the loop through the chromosomes there is an R 
    # Object (`sure.indel.allchrom`) that contains all desired variants
    # for one specific replicate. iPCR data (`counts`) and cDNA counts 
    # (e.g. SuRE42_2_HepG2_B1) should be normalized to reads per billion
    #
    # With this we have to keep in mind that we downsampled for 42.1 (both cell lines) and 43.1 (HepG2 only), therefore
    # we also have to adjust the normalization for these samples
    
    if (rep.str == "42_1"){
      sure.snp_indel.allparent$count <- round(sure.snp_indel.allparent$count / sum.counts * 1e9, digits = 2)
      sure.snp_indel.allparent[,14]   <- round(sure.snp_indel.allparent[,14] / (sum.cdna1 * c(downsample.k562.42.1,downsample.hepg2.42.1)[1]) * 1e9, digits = 1)
      sure.snp_indel.allparent[,15]  <- round(sure.snp_indel.allparent[,15] / (sum.cdna2 * c(downsample.k562.42.1,downsample.hepg2.42.1)[2]) * 1e9, digits = 1)
      sure.snp_indel.allparent[,16]  <- round(sure.snp_indel.allparent[,16] / (sum.cdna3 * c(downsample.k562.42.1,downsample.hepg2.42.1)[3]) * 1e9, digits = 1)
      sure.snp_indel.allparent[,17]  <- round(sure.snp_indel.allparent[,17] / (sum.cdna4 * c(downsample.k562.42.1,downsample.hepg2.42.1)[4]) * 1e9, digits = 1)
      sure.snp_indel.allparent[,18]  <- round(sure.snp_indel.allparent[,18] / (sum.cdna5 * c(downsample.k562.42.1,downsample.hepg2.42.1)[5]) * 1e9, digits = 1)
    } else if (rep.str == "43_1") {
      sure.snp_indel.allparent$count <- round(sure.snp_indel.allparent$count / sum.counts * 1e9, digits = 2)
      sure.snp_indel.allparent[,14]   <- round(sure.snp_indel.allparent[,14] / sum.cdna1 * 1e9, digits = 1)
      sure.snp_indel.allparent[,15]  <- round(sure.snp_indel.allparent[,15] / sum.cdna2 * 1e9, digits = 1)
      sure.snp_indel.allparent[,16]  <- round(sure.snp_indel.allparent[,16] / sum.cdna3 * 1e9, digits = 1)
      sure.snp_indel.allparent[,17]  <- round(sure.snp_indel.allparent[,17] / (sum.cdna4 * downsample.hepg2.43.1[1]) * 1e9, digits = 1)
      sure.snp_indel.allparent[,18]  <- round(sure.snp_indel.allparent[,18] / (sum.cdna5 * downsample.hepg2.43.1[2]) * 1e9, digits = 1)
    } else {
      sure.snp_indel.allparent$count <- round(sure.snp_indel.allparent$count / sum.counts * 1e9, digits = 2)
      sure.snp_indel.allparent[,14]   <- round(sure.snp_indel.allparent[,14] / sum.cdna1 * 1e9, digits = 1)
      sure.snp_indel.allparent[,15]  <- round(sure.snp_indel.allparent[,15] / sum.cdna2 * 1e9, digits = 1)
      sure.snp_indel.allparent[,16]  <- round(sure.snp_indel.allparent[,16] / sum.cdna3 * 1e9, digits = 1)
      sure.snp_indel.allparent[,17]  <- round(sure.snp_indel.allparent[,17] / sum.cdna4 * 1e9, digits = 1)
      sure.snp_indel.allparent[,18]  <- round(sure.snp_indel.allparent[,18] / sum.cdna5 * 1e9, digits = 1)
    }
    
    
    
    
    
    
    
    # To concatonate the R objects containing all chromosomes for every replicate,
    # The columnnames of these objects should be an exact match. For every first replicate (e.g. 44-1) and 45-2
    # They are in the order K562 B1-B3 and then HepG2 B1-2. While for every second replicate (e.g. 44-2)
    # The order is reversed (HepG2 B1-B2 followed by K562 B1-B3). Column names are altered with the following script
    
    print(head(sure.snp_indel.allparent))
    if (replicate %in% (c("SuRE42-1/","SuRE43-1/","SuRE44-1/", "SuRE45-1/", "SuRE45-2/"))){
      colnames(sure.snp_indel.allparent)[14:18] <- c("cDNA.K562.B1", "cDNA.K562.B2", "cDNA.K562.B3", "cDNA.HepG2.B1", "cDNA.HepG2.B2")} else {
        colnames(sure.snp_indel.allparent)[14:18] <- c("cDNA.HepG2.B1", "cDNA.HepG2.B2", "cDNA.K562.B1", "cDNA.K562.B2", "cDNA.K562.B3")
      }
    print(head(sure.snp_indel.allparent))
    
    # Average the data of the 3 (K562) or 2 (HepG2) biological replicates and normalize to ipcr counts
    
    sure.snp_indel.allparent$cDNA.K562.sum.norm <- (sure.snp_indel.allparent$cDNA.K562.B1 + sure.snp_indel.allparent$cDNA.K562.B2 + sure.snp_indel.allparent$cDNA.K562.B3) / 3
    sure.snp_indel.allparent$cDNA.HepG2.sum.norm <- (sure.snp_indel.allparent$cDNA.HepG2.B1 + sure.snp_indel.allparent$cDNA.HepG2.B2) / 2
    
    sure.snp_indel.allparent$cDNA.K562.norm.ipcr <- sure.snp_indel.allparent$cDNA.K562.sum.norm / sure.snp_indel.allparent$count
    sure.snp_indel.allparent$cDNA.HepG2.norm.ipcr <- sure.snp_indel.allparent$cDNA.HepG2.sum.norm / sure.snp_indel.allparent$count
    
    # For every chromosome, the R object containing the variants is saved
    # into the /combined directory of that specific replicate
    
    saveRDS(sure.snp_indel.allparent, file = paste0("/DATA/usr/n.klaassen/projects/SuRE_K562/tmp/example.chr15/", rep.str, "combined.","sure.",".counts.snp_indel.", chrom, ".RDS"))
    
    

  print(paste(replicate, "finished at", Sys.time()))

 ### END LOOP REP 1:7 ###

print(paste0("script 1 (importing) completely finished at ", Sys.time()))




